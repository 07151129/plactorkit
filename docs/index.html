<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PlausibleActorKit: Plausible ActorKit</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Plausible ActorKit</h1>
<p>
<h2><a class="anchor" name="intro_sec">
Introduction</a></h2>
ActorKit provides an Objective-C implementation of asynchronous inter-thread message passing.<p>
The purpose of ActorKit is to facilitate the implementation of concurrent software on both the desktop (Mac OS X) and embedded devices (iPhone OS). On the iPhone, thread-based concurrency is a critical tool in achieving high interface responsiveness while implementing long-running and potentially computationally expensive background processing. On Mac OS X, thread-based concurrency opens the door to leveraging the power of increasingly prevalent multi-core desktop computers.<p>
To this end, ActorKit endeavours to provide easily understandable invariants for concurrent software:<p>
<ul>
<li>All threads are actors.</li><li>Any actor may create additional actors.</li><li>Any actor may asynchronously deliver a message to another actor.</li><li>An actor may synchronously wait for message delivery from another actor.</li></ul>
<p>
As an actor may only synchronously receive messages, no additional concurrency primitives are required, such as mutexes or condition variables.<p>
Building on this base concurrency model, ActorKit provides facilities for proxying Objective-C method invocations between threads, providing direct, transparent, synchronous and asynchronous execution of Objective-C methods on actor threads.<h2><a class="anchor" name="actor_basics">
Actor Creation and Simple Message Passing</a></h2>
<h3><a class="anchor" name="actor_basics_messages">
Messages</a></h3>
The Actor model of concurrency is fundamentally based on communication between isolated actors through asynchronous message passing. In ActorKit, any Objective-C object conforming to the NSObject protocol may be used as an inter-actor message, but message objects should be immutable to ensure thread safety. ActorKit, being written in Objective-C, can not enforce message immutablity or full isolation of Actor threads. It is entirely possible to pass mutable messages, or access mutable global variables. Like many other libraries implementing Actor message passing semantics, isolation is maintained purely through convention.<p>
While ActorKit supports messaging with any Objective-C object, the <a class="el" href="interface_p_l_actor_message.html" title="A reusable base class for messaging.">PLActorMessage</a> class provides generally useful facilities such as unique message transaction ids, automatically determining the message sender, and including additional message payloads.<h3><a class="anchor" name="actor_basics_processes">
Actor Proceses</a></h3>
In ActorKit, all threads are fully functioning actors -- including the "main" Cocoa thread. Each actor is represented by a <a class="el" href="protocol_p_l_actor_process-p.html" title="An Actor process instance.">PLActorProcess</a> instance, which may be passed to any other running actors, and is used to send messages asynchronously to the given process.<p>
ActorKit ensures that all message reception within a given actor occurs serially, and provides strict guarantees on message ordering -- messages M1 and M2 sent from actor A1 will be delivered to actor A2 in the same order. However, delivery of messages from actor A1 may be interspersed with delivery of messages sent by other actors:<p>
<div align="center">
<img src="inline_mscgraph_1.png" alt="inline_mscgraph_1" border="0" usemap="#inline_mscgraph_1.map">
<map name="inline_mscgraph_1.map"></map>
</div>
<p>
In the future, ActorKit may be extended to leverage Apple's Grand Central [1] to provide hybrid event/thread M:N scheduling of actor execution on available cores, an approach presented by Philipp Haller and Martin Odersky and implemented in Scala's Actor library [2].<h3><a class="anchor" name="actor_basics_example">
A Simple Echo Actor</a></h3>
<div class="fragment"><pre class="fragment">  - (void) echo {
     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
     <a class="code" href="interface_p_l_actor_message.html" title="A reusable base class for messaging.">PLActorMessage</a> *message;

     <span class="comment">// Loop forever, receiving messages</span>
     <span class="keywordflow">while</span> ((message = [<a class="code" href="interface_p_l_actor_kit.html" title="Provides support for spawning new actors and receiving actor messages.">PLActorKit</a> receive]) != nil) {
         <span class="comment">// Echo the same message back to the sender.</span>
         [[message sender] send: message];

         <span class="comment">// Flush the autorelease pool through every loop iteration</span>
         [pool release];
         pool = [[NSAutoreleasePool alloc] init];
     }

     [pool release];
 }

 - (void) run {
     <span class="comment">// Spawn a new actor thread. This will return a process instance which may be used</span>
     <span class="comment">// to deliver messages the new actor.</span>
     id&lt;PLActorProcess&gt; proc = [<a class="code" href="interface_p_l_actor_kit.html" title="Provides support for spawning new actors and receiving actor messages.">PLActorKit</a> spawnWithTarget: <span class="keyword">self</span> selector: @selector(echo:)];

     <span class="comment">// Send a simple message to the actor.</span>
     [proc send: [<a class="code" href="interface_p_l_actor_message.html" title="A reusable base class for messaging.">PLActorMessage</a> messageWithObject: <span class="stringliteral">@"Hello"</span>]];

     <span class="comment">// Wait for the echo</span>
     <a class="code" href="interface_p_l_actor_message.html" title="A reusable base class for messaging.">PLActorMessage</a> *message = [<a class="code" href="interface_p_l_actor_kit.html" title="Provides support for spawning new actors and receiving actor messages.">PLActorKit</a> receive];
 }
</pre></div><h2><a class="anchor" name="actor_rpc">
Sending Synchronous Messages with Actors</a></h2>
In an Actor system where all messages are sent asynchronously, synchronous messaging may be achieved with the following steps:<p>
<ul>
<li>Allocate a unique transaction id</li><li>Send a message with that transaction id</li><li>Wait for a reply with a matching transaction id.</li></ul>
<p>
Message Sequence: <div align="center">
<img src="inline_mscgraph_2.png" alt="inline_mscgraph_2" border="0" usemap="#inline_mscgraph_2.map">
<map name="inline_mscgraph_2.map"></map>
</div>
<p>
ActorKit provides facilities for handling this common usage scenario. Unique transaction ids may be generated via the <a class="el" href="interface_p_l_actor_kit.html#f21c16c72cad51f2cff56e86fca8ffcc" title="Generate a unique transaction ID; the ID will be unique within the current actor...">createTransactionId (PLActorKit)</a> method, and every <a class="el" href="interface_p_l_actor_message.html" title="A reusable base class for messaging.">PLActorMessage</a> generates and uses a new transactionId.<p>
The <a class="el" href="interface_p_l_actor_r_p_c.html" title="Provides remote procedure call services.">PLActorRPC</a> class utilizes the PLActorMessage's transaction id to wait for a reply on your behalf.<p>
Send a message, and wait for the reply: <div class="fragment"><pre class="fragment"> id&lt;PLActorProcess&gt; helloActor = [<a class="code" href="interface_p_l_actor_kit.html" title="Provides support for spawning new actors and receiving actor messages.">PLActorKit</a> spawnWithTarget: <span class="keyword">self</span> selector: @selector(helloActor:)];
 <a class="code" href="interface_p_l_actor_message.html" title="A reusable base class for messaging.">PLActorMessage</a> *message = [<a class="code" href="interface_p_l_actor_message.html" title="A reusable base class for messaging.">PLActorMessage</a> messageWithObject: <span class="stringliteral">@"Hello"</span>];
 <a class="code" href="interface_p_l_actor_message.html" title="A reusable base class for messaging.">PLActorMessage</a> *reply = [<a class="code" href="interface_p_l_actor_r_p_c.html" title="Provides remote procedure call services.">PLActorRPC</a> sendRPC: message toProcess: helloActor];
</pre></div><h2><a class="anchor" name="actor_rpc_objc">
Transparently Proxying Objective-C Messages with Actors</a></h2>
ActorKit provides two NSProxy subclasses which provide <b>transparent</b> proxying of Objective-C synchronous and asynchronous method invocations via actor messaging. <a class="el" href="interface_p_l_actor_r_p_c_proxy.html" title="The PLActorProxy provides transparent invocation of Objective-C messages on a local...">PLActorRPCProxy</a> spawns a new actor to execute Objective-C methods for a given object instance, while <a class="el" href="interface_p_l_runloop_r_p_c_proxy.html" title="The PLRunloopRPCProxy provides transparent invocation of Objective-C messages on...">PLRunloopRPCProxy</a> executes Objective-C methods on a provided NSRunLoop.<p>
In combination, these classes allow for safely and transparenty executing methods on Objective-C instances from any thread:<p>
<div class="fragment"><pre class="fragment"> NSString *actorString = [<a class="code" href="interface_p_l_actor_r_p_c_proxy.html" title="The PLActorProxy provides transparent invocation of Objective-C messages on a local...">PLActorRPCProxy</a> proxyWithTarget: <span class="stringliteral">@"Hello"</span>];
 NSString *runloopString = [<a class="code" href="interface_p_l_runloop_r_p_c_proxy.html" title="The PLRunloopRPCProxy provides transparent invocation of Objective-C messages on...">PLRunloopRPCProxy</a> proxyWithTarget: <span class="stringliteral">@"Hello"</span> runLoop: [NSRunLoop mainRunLoop]];

 <span class="comment">// Executes synchronously, via a newly created actor thread.</span>
 [actorString description];

 <span class="comment">// Executes synchronously, on the main runloop.</span>
 [runloopString description];
</pre></div><p>
By default, <a class="el" href="interface_p_l_actor_r_p_c_proxy.html" title="The PLActorProxy provides transparent invocation of Objective-C messages on a local...">PLActorRPCProxy</a> and <a class="el" href="interface_p_l_runloop_r_p_c_proxy.html" title="The PLRunloopRPCProxy provides transparent invocation of Objective-C messages on...">PLRunloopRPCProxy</a> will execute methods synchronously, waiting for completion prior to returning. In order to execute a method asynchronously -- allowing a long running method to execute without waiting for completion -- it is necessary to mark methods for asynchronous execution.<p>
The Objective-C runtime provides a number of type qualifiers that were intended for use in implementing a Distributed Object system. Of particular note is the 'oneway' qualifier, which allows us to specify that a method should be invoked asynchronously.<p>
When a method is declared with a return value of 'oneway void', the proxy classes will introspect this return value, and execute the method asynchronously, without waiting for a reply:<p>
<div class="fragment"><pre class="fragment"> - (oneway void) asyncMethod {
    <span class="comment">// Execute, asynchronously</span>
 }
</pre></div><p>
<div align="center">
<img src="inline_mscgraph_3.png" alt="inline_mscgraph_3" border="0" usemap="#inline_mscgraph_3.map">
<map name="inline_mscgraph_3.map"></map>
</div>
<p>
<div class="fragment"><pre class="fragment"> - (NSString *) synchronousMethod {
    <span class="comment">// Execute, synchronously</span>
    <span class="keywordflow">return</span> <span class="stringliteral">@"Hello"</span>;
 }
</pre></div><p>
<div align="center">
<img src="inline_mscgraph_4.png" alt="inline_mscgraph_4" border="0" usemap="#inline_mscgraph_4.map">
<map name="inline_mscgraph_4.map"></map>
</div>
<h3><a class="anchor" name="actor_rpc_objc_example">
A Simple Echo Actor with PLActorRPCProxy</a></h3>
The following actor returns a proxy from its init method, ensuring that all methods called on the object instance will occur via the actor thread.<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// An actor that responds to Objective-C messages either synchronously or asynchronously.</span>
 <span class="keyword">@implementation </span>EchoActor

 - (id) init {
     <span class="keywordflow">if</span> ((<span class="keyword">self</span> = [super init]) == nil)
         <span class="keywordflow">return</span> nil;
 
     <span class="comment">// Launch our actor</span>
     <span class="keywordtype">id</span> proxy = [[<a class="code" href="interface_p_l_actor_r_p_c_proxy.html" title="The PLActorProxy provides transparent invocation of Objective-C messages on a local...">PLActorRPCProxy</a> alloc] initWithTarget: self];

     <span class="comment">// Release ourself, as the proxy has retained our object,</span>
     <span class="comment">// and return our proxy to the caller</span>
     [<span class="keyword">self</span> release];
     <span class="keywordflow">return</span> proxy;
 }

 <span class="comment">// Method is called asynchronously</span>
 - (oneway void) asynchronousEcho: (NSString *) text listener: (EchoListener *) echoListener {
     [echoListener receiveEcho: text];
 }

 <span class="comment">// Method is called synchronously</span>
 - (NSString *) synchronousEcho: (NSString *) text {
     <span class="keywordflow">return</span> text;
 }

 <span class="keyword">@end</span>
</pre></div><h2><a class="anchor" name="services">
Integration &amp; Development Services</a></h2>
ActorKit is provided free of charge under the BSD license, and may be freely integrated with any application. We can provide assistance with integrating our code in your own iPhone or Mac application, as well as development of additional features under a license of your choosing.<p>
Contact Plausible Labs for more information: <a href="http://www.plausiblelabs.com">http://www.plausiblelabs.com</a><h2><a class="anchor" name="References">
References</a></h2>
[1] Grand Central (technology), Wikipedia contributors, Wikipedia, The Free Encyclopedia, November 19, 2008, 17:13 UTC. Available from <a href="http://en.wikipedia.org/w/index.php?title=Grand_Central_(technology)&oldid=252808705">http://en.wikipedia.org/w/index.php?title=Grand_Central_(technology)&amp;oldid=252808705</a>. Accessed November 19, 2008.<p>
[2] Actors that Unify Threads and Events, Philipp Haller and Martin Odersky, LAMP-REPORT-2007-001, EPFL, January 2007. Available from <a href="http://lamp.epfl.ch/~phaller/actors.html">http://lamp.epfl.ch/~phaller/actors.html</a>. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jan 5 11:36:26 2009 for PlausibleActorKit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
